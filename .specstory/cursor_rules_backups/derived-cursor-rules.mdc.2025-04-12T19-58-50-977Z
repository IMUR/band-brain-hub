
## PROJECT OVERVIEW
Band Brain Hub is a single-page, mobile-critical web application designed for band members to collaboratively manage events, tasks, notes, finances, and setlists. The application prioritizes rapid deployment, excellent UX/UI, and seamless real-time synchronization. Offline support is crucial. The application is implemented as a single-file application using Svelte 5, TypeScript, and Tailwind CSS, leveraging IndexedDB for persistence and local JSON-like data structures. Authentication is already implemented.  The application uses an internal JSON-based data layer for persistence. Data persistence is managed via local JSON-like structures within TypeScript and IndexedDB.

## CODE STYLE
Consistent with standard Svelte/TypeScript best practices. Emphasis on readability and maintainability.  Avoid JSX-style comments in Svelte components. Use standard Svelte comment syntax.

## FOLDER ORGANIZATION
The project uses a minimized folder structure. Core application logic resides in `src/App.svelte`.  Additional files include `package.json`, `vite.config.ts`, `tailwind.config.js`, `postcss.config.js`, `tsconfig.json`, `index.html`, `src/app.css`, `src/main.ts`, and a `src/components` folder (currently empty).  A `src/data` folder may be added for storing JSON data.  A `.gitignore` file should be created to manage ignored files and folders (see WORKFLOW & RELEASE RULES for details).

## TECH STACK
Svelte 5, TypeScript, Tailwind CSS, Font Awesome, uuid, IndexedDB, Vite (build tool), idb, tslib, @tsconfig/svelte, @sveltejs/vite-plugin-svelte, autoprefixer, postcss, Bun (package manager and Javascript runtime), Node.js (optional), @tailwindcss/postcss, puppeteer

## PROJECT-SPECIFIC STANDARDS
- All data is persisted locally using IndexedDB and managed via local JSON-like structures within TypeScript.
- The application is designed as a single-file application for ease of deployment and maintenance (using Vite for development).
- UI should be intuitive for users with varying levels of technical expertise.  The application should maintain a conversational tone in interactions with users.
- Reactive, real-time updates are implemented using Svelte 5 runes.
- Offline support is provided through IndexedDB integration.
- Bun is the preferred package manager and Javascript runtime. Node.js is optional.  Use `bun run dev` for development and `bun run build` for production builds. If Bun is slow, try clearing the cache with `bun pm cache rm`.
- The application uses an internal JSON-based data layer for persistence.
- `tsconfig.json` and `tsconfig.node.json` must be configured correctly to avoid TypeScript errors.  The `"strict"` and `"forceConsistentCasingInFileNames"` compiler options should be enabled.  `tsconfig.node.json` is required for Vite even when using Bun.
- The `compatibility.componentApi` compiler option must be set to `4` in `tsconfig.json` to address Svelte 5 component instantiation issues.
- Use `bun vite` (not `bunx --bun vite`) for development, build, and preview commands for efficiency.
- Use `bun run build --watch` to rebuild automatically when changes are detected.


## WORKFLOW & RELEASE RULES
Rapid iterative development and deployment cycles. Prioritize features based on user needs and feedback. Use `bun run dev` for development and `bun run build` for production builds. Use `bun run preview` for previewing production builds. A comprehensive `.gitignore` file must be used to manage ignored files and folders.  The `.gitignore` file should include entries for dependencies, build artifacts, environment variables, debug logs, IDE files, OS files, and common build artifacts and caches (see REFERENCE EXAMPLES for a sample `.gitignore` file).  Hot-swapping (hot module replacement) is available only during development (`bun run dev`) and not during preview (`bun run preview`) or production builds. Use `bun vite` (not `bunx --bun vite`) for development, build, and preview commands for efficiency. Use `bun run build --watch` to rebuild automatically when changes are detected.  Use `bun vite` for all commands instead of `bunx --bun vite`.

## REFERENCE EXAMPLES
- **.gitignore:**

```
# Dependencies
node_modules/
/.pnp
.pnp.js
yarn.lock
package-lock.json

# Testing
/coverage
.nyc_output

# Production/Build
/build
/dist
/.next/
/out/
.nuxt
.output

# Environment Variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
.env*.local

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# IDEs and Editors
/.idea
.project
.classpath
.settings/
*.sublime-workspace
*.sublime-project
.vscode/*
!.vscode/extensions.json
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json

# OS Files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Misc
*.log
*.csv
*.dat
*.out
*.pid
*.seed
*.pid.lock
.lock-wscript
.node_repl_history
.npm
.eslintcache
.stylelintcache
.cache
.parcel-cache
.serverless/
.fusebox/
.dynamodb/
.tern-port
.webpack/
.svelte-kit
.vercel
.turbo

# TypeScript
*.tsbuildinfo
next-env.d.ts
```

## PROJECT DOCUMENTATION & CONTEXT SYSTEM
All documentation is embedded within the `app.svelte` file (post-build) through comments and type definitions.

## DEBUGGING
Standard browser developer tools.  If Bun is slow, try clearing the cache with `bun pm cache rm`. Use `bun run dev` for development.  Use browser developer tools. Address "effect_orphan" errors by ensuring `$effect` runes are used correctly within component lifecycles, avoiding async operations directly within them.  Ensure proper error handling within `$effect` blocks. Address "component_api_invalid_new" errors by setting the `compatibility.componentApi` compiler option to `4` in `tsconfig.json`.  Avoid using `new` keyword to instantiate Svelte components in Svelte 5. Use the functional approach instead.  Address "effect_orphan" errors by ensuring asynchronous operations within `$effect` blocks are handled correctly. Consider using a script to automate the process loop involving Puppeteer, browser tools, and rebuilds.  A script to automate testing and build processes using Puppeteer is recommended (see FINAL DOs AND DON'Ts). Use puppeteer_navigate, puppeteer_screenshot, puppeteer_click, puppeteer_fill, puppeteer_select, puppeteer_hover, puppeteer_evaluate as needed for testing and debugging.

## FINAL DOs AND DON'Ts
- **DO** prioritize simplicity and ease of use.
- **DO** ensure the application is mobile-friendly and responsive.
- **DO** maintain a consistent and visually appealing design.
- **DO** use clear and concise language in all interactions.
- **DO** use Bun as the package manager and Javascript runtime. Node.js is optional.
- **DO** use an internal JSON-based data layer for persistence.
- **DO** configure `tsconfig.json` and `tsconfig.node.json` correctly, enabling `"strict"` and `"forceConsistentCasingInFileNames"` compiler options.  The `compatibility.componentApi` compiler option must be set to `4` in `tsconfig.json`.
- **DO** create and maintain a comprehensive `.gitignore` file.
- **DON'T** use external backend services (e.g., Supabase).
- **DON'T** over-engineer solutions; strive for simplicity.
- **DO** use `bun run dev` for development and `bun run build` for production builds.  Use `bun run preview` for previewing production builds. Use `bun vite` (not `bunx --bun vite`) for all commands.
- **DO** use standard Svelte comment syntax, avoid JSX-style comments.
- **DO** ensure that asynchronous operations within `$effect` blocks are handled correctly to avoid "effect_orphan" errors.
- **DO** use the functional approach (not `new`) to instantiate Svelte components in Svelte 5.
- **DO** configure `tailwind.config.js` to include `"./src/**/*.{js,ts,jsx,tsx,svelte}"` in the `content` array.
- **DO** Use `bun vite` for all commands instead of `bunx --bun vite`.
- **DO** Use `bun run build --watch` to rebuild automatically when changes are detected.
- **DO** Consider using a script to automate the process loop involving Puppeteer, browser tools, and rebuilds. Example process steps: 1. check browser-tools MCP: getConsoleLogs, getConsoleErrors, getNetworkLogs, takeScreenshot; 2. attempt fix; 3. update memory: read_graph, search_nodes, open_nodes, create_entities, create_relations, add_observations; 4. run: `bun run build`; 5. use puppeteer MCP tools; 6. check browser-tools MCP: getConsoleLogs, getConsoleErrors, getNetworkLogs, takeScreenshot; 7. undo ineffective attempted fixes; 8. use browser-tools MCP: (only wipelogs tool); 9. run `bun run build`. Repeat.  This process should include two phases: initial fixing and verification, with backups before applying fixes and robust error handling.  This automated process should utilize puppeteer_navigate, puppeteer_screenshot, puppeteer_click, puppeteer_fill, puppeteer_select, puppeteer_hover, and puppeteer_evaluate as appropriate.
- **DO** Use `bun vite` for all commands instead of `bunx --bun vite`.
- **DO**  Follow this automated process loop:
1. check browser-tools MCP: getConsoleLogs, getConsoleErrors, getNetworkLogs, getNetworkErrors, takeScreenshot, runPerformanceAudit
2. attempt fix based on diagnostic information
3. update memory MCP: read_graph, search_nodes, open_nodes, create_entities, create_relations, add_observations
4. run: bun run build
5. use puppeteer MCP: puppeteer_navigate, puppeteer_click, puppeteer_fill, puppeteer_select, puppeteer_hover, puppeteer_evaluate, puppeteer_screenshot
6. check browser-tools MCP: getConsoleLogs, getConsoleErrors, getNetworkLogs, getNetworkErrors, takeScreenshot, runAccessibilityAudit
7. undo ineffective attempted fixes (if errors persist or new ones appear)
   - memory MCP: delete_entities, delete_relations, delete_observations
   - revert code changes
8. use browser-tools MCP: wipeLogs
9. run: bun run build
10. Repeat